/-
# Critical Pairs for First-Order TRSs

Defines overlaps and critical pairs using unifiers and term positions.
-/

import Metatheory.TRS.FirstOrder.Rules
import Metatheory.TRS.FirstOrder.Positions
import Metatheory.TRS.FirstOrder.Unification
import Metatheory.TRS.FirstOrder.UnificationComplete
import Mathlib.Data.List.FinRange

namespace Metatheory.TRS.FirstOrder

open Term

/-! ## Variable and Unification Predicates -/

/-- Predicate: term is a variable. -/
def IsVar {sig : Signature} : Term sig -> Prop
  | Term.var _ => True
  | Term.app _ _ => False

/-- Predicate: term is not a variable. -/
abbrev NonVar {sig : Signature} (t : Term sig) : Prop := ¬ IsVar t

@[simp] theorem isVar_var {sig : Signature} (x : Nat) : IsVar (Term.var (sig := sig) x) := by
  simp [IsVar]

@[simp] theorem nonVar_app {sig : Signature} (f : sig.Sym) (args : Fin (sig.arity f) -> Term sig) :
    NonVar (Term.app f args) := by
  simp [NonVar, IsVar]

/-- A substitution unifies two terms if it makes them equal. -/
def Unifies {sig : Signature} (sub : Subst sig) (s t : Term sig) : Prop :=
  Term.subst sub s = Term.subst sub t

theorem unifies_refl {sig : Signature} (sub : Subst sig) (t : Term sig) :
    Unifies sub t t := by
  rfl

theorem unifies_symm {sig : Signature} {sub : Subst sig} {s t : Term sig} :
    Unifies sub s t -> Unifies sub t s := by
  intro h
  simpa [Unifies] using h.symm

theorem unifies_trans {sig : Signature} {sub : Subst sig} {s t u : Term sig} :
    Unifies sub s t -> Unifies sub t u -> Unifies sub s u := by
  intro hst htu
  dsimp [Unifies] at hst htu ⊢
  exact hst.trans htu

theorem unifies_comp {sig : Signature} {sub tau : Subst sig} {s t : Term sig}
    (h : Unifies sub s t) : Unifies (Term.compSubst tau sub) s t := by
  dsimp [Unifies] at h ⊢
  have h' := congrArg (Term.subst tau) h
  simpa [Term.subst_comp] using h'

/-! ## Critical Pairs -/

/-- Overlap witness: an LHS instance contains another LHS instance at a position. -/
def Overlap {sig : Signature} (r1 r2 : Rule sig) (p : Pos)
    (sub1 sub2 : Subst sig) : Prop :=
  Term.subterm (Term.subst sub1 r1.lhs) p = some (Term.subst sub2 r2.lhs) ∧
  NonVar (Term.subst sub2 r2.lhs)

/-- A critical pair is a pair of terms derived from overlapping rules. -/
structure CriticalPair (sig : Signature) where
  left : Term sig
  right : Term sig

/-- Build a critical pair from an overlap, if the replacement is defined. -/
def mkCriticalPair {sig : Signature} (r1 r2 : Rule sig) (p : Pos)
    (sub1 sub2 : Subst sig) : Option (CriticalPair sig) :=
  match Term.replace (Term.subst sub1 r1.lhs) p (Term.subst sub2 r2.rhs) with
  | none => none
  | some t => some ⟨Term.subst sub1 r1.rhs, t⟩

theorem mkCriticalPair_defined_of_subterm {sig : Signature} {r1 r2 : Rule sig}
    {p : Pos} {t : Term sig} {sub1 sub2 : Subst sig} :
    Term.subterm r1.lhs p = some t →
    ∃ cp, mkCriticalPair r1 r2 p sub1 sub2 = some cp := by
  intro hsub
  have hsub' :
      Term.subterm (Term.subst sub1 r1.lhs) p = some (Term.subst sub1 t) := by
    exact Term.subterm_subst (sub := sub1) (t := r1.lhs) (p := p) (u := t) hsub
  have hrep_self :
      Term.replace (Term.subst sub1 r1.lhs) p (Term.subst sub1 t) =
        some (Term.subst sub1 r1.lhs) := by
    exact Term.replace_self (t := Term.subst sub1 r1.lhs) (p := p) (u := Term.subst sub1 t) hsub'
  rcases Term.replace_defined_of_replace
      (t := Term.subst sub1 r1.lhs) (p := p) (u := Term.subst sub1 t)
      (t' := Term.subst sub1 r1.lhs) hrep_self (Term.subst sub2 r2.rhs) with ⟨t', hrep⟩
  exact ⟨⟨Term.subst sub1 r1.rhs, t'⟩, by simp [mkCriticalPair, hrep]⟩

@[simp] theorem mkCriticalPair_root {sig : Signature} (r1 r2 : Rule sig)
    (sub1 sub2 : Subst sig) :
    mkCriticalPair r1 r2 [] sub1 sub2 =
      some ⟨Term.subst sub1 r1.rhs, Term.subst sub2 r2.rhs⟩ := by
  simp [mkCriticalPair]

/-- A finite list of rules. -/
abbrev RuleList (sig : Signature) := List (Rule sig)

/-- Rule set generated by a list. -/
def ruleSetOfList {sig : Signature} (rules : RuleList sig) : RuleSet sig :=
  fun r => r ∈ rules

/-- Positions of all subterms (including root). -/
def Term.positions {sig : Signature} : Term sig → List Pos
  | Term.var _ => [[]]
  | Term.app f args =>
      [] :: (List.finRange (sig.arity f)).flatMap (fun i =>
        (positions (args i)).map (fun p => (i.val :: p)))

theorem mem_positions_of_subterm {sig : Signature} {t u : Term sig} {p : Pos} :
    Term.subterm t p = some u → p ∈ Term.positions t := by
  intro hsub
  induction t generalizing p u with
  | var x =>
      cases p with
      | nil =>
          simp [Term.subterm] at hsub
          simp [Term.positions]
      | cons i ps =>
          cases (by simp [Term.subterm] at hsub : False)
  | app f args ih =>
      cases p with
      | nil =>
          simp [Term.subterm] at hsub
          simp [Term.positions]
      | cons i ps =>
          by_cases hi : i < sig.arity f
          ·
            have hsub' : Term.subterm (args ⟨i, hi⟩) ps = some u := by
              simp [Term.subterm, hi] at hsub
              exact hsub
            have hmem : ps ∈ Term.positions (args ⟨i, hi⟩) :=
              ih ⟨i, hi⟩ (p := ps) (u := u) hsub'
            have hmem' : (i :: ps) ∈ (List.finRange (sig.arity f)).flatMap
                (fun j => (Term.positions (args j)).map (fun q => j.val :: q)) := by
              apply List.mem_flatMap.2
              refine ⟨⟨i, hi⟩, ?_, ?_⟩
              · exact List.mem_finRange ⟨i, hi⟩
              ·
                apply List.mem_map.2
                refine ⟨ps, hmem, ?_⟩
                rfl
            simp [Term.positions, hmem', List.mem_cons]
          ·
            cases (by simp [Term.subterm, hi] at hsub : False)

theorem subterm_of_mem_positions {sig : Signature} {t : Term sig} {p : Pos} :
    p ∈ Term.positions t → ∃ u, Term.subterm t p = some u := by
  intro hmem
  induction t generalizing p with
  | var x =>
      cases p with
      | nil =>
          exact ⟨Term.var x, by simp [Term.subterm]⟩
      | cons i ps =>
          cases (by simp [Term.positions] at hmem : False)
  | app f args ih =>
      cases p with
      | nil =>
          exact ⟨Term.app f args, by simp [Term.subterm]⟩
      | cons i ps =>
          have hmem' :
              (i :: ps) ∈
                (List.finRange (sig.arity f)).flatMap
                  (fun j => (Term.positions (args j)).map (fun q => j.val :: q)) := by
            simpa [Term.positions] using hmem
          rcases List.mem_flatMap.1 hmem' with ⟨j, hj, hmemj⟩
          rcases List.mem_map.1 hmemj with ⟨q, hq, hqeq⟩
          cases hqeq
          have hi : j.val < sig.arity f := j.isLt
          rcases ih j (p := ps) hq with ⟨u, hsub⟩
          exact ⟨u, by simpa [Term.subterm, hi] using hsub⟩

/-- Return all overlaps of two rules using unification. -/
def overlapsOfRules {sig : Signature} [DecidableEq sig.Sym]
    (r1 r2 : Rule sig) : List (Pos × Subst sig × Subst sig) :=
  (Term.positions (sig := sig) r1.lhs).filterMap (fun p =>
    match Term.subterm r1.lhs p with
    | none => none
    | some t =>
        match unify (sig := sig) [(t, r2.lhs)] with
        | none => none
        | some sub => some (p, sub, sub))

theorem overlapsOfRules_complete {sig : Signature} [DecidableEq sig.Sym]
    {r1 r2 : Rule sig} {p : Pos} {t : Term sig} {sub : Subst sig} :
    Term.subterm r1.lhs p = some t →
    unify (sig := sig) [(t, r2.lhs)] = some sub →
    (p, sub, sub) ∈ overlapsOfRules r1 r2 := by
  intro hsub hunify
  unfold overlapsOfRules
  refine List.mem_filterMap.2 ?_
  refine ⟨p, mem_positions_of_subterm hsub, ?_⟩
  simp [hsub, hunify]

theorem overlapsOfRules_complete_unifiable {sig : Signature} [DecidableEq sig.Sym]
    {r1 r2 : Rule sig} {p : Pos} {t : Term sig} :
    Term.subterm r1.lhs p = some t →
    Unifiable (sig := sig) [(t, r2.lhs)] →
    ∃ sub, (p, sub, sub) ∈ overlapsOfRules r1 r2 := by
  intro hsub hunif
  rcases (unifiable_iff_unify (sig := sig) (eqs := [(t, r2.lhs)])).1 hunif with ⟨sub, hunify⟩
  exact ⟨sub, overlapsOfRules_complete (r1 := r1) (r2 := r2) hsub hunify⟩

/-- Finite list of critical pairs for a rule list. -/
def criticalPairsOfRules {sig : Signature} [DecidableEq sig.Sym]
    (rules : RuleList sig) : List (CriticalPair sig) :=
  (rules.flatMap fun r1 =>
    rules.flatMap fun r2 =>
      (overlapsOfRules r1 r2).filterMap (fun o =>
        match o with
        | (p, sub1, sub2) => mkCriticalPair r1 r2 p sub1 sub2))

def overlapsOfRulesBounded {sig : Signature} [DecidableEq sig.Sym]
    (r1 r2 : Rule sig) : List (Pos × Subst sig × Subst sig) :=
  (Term.positions (sig := sig) r1.lhs).filterMap (fun p =>
    match Term.subterm r1.lhs p with
    | none => none
    | some t =>
        match unifyBounded (sig := sig) [(t, r2.lhs)] with
        | none => none
        | some sub => some (p, sub, sub))

def criticalPairsOfRulesBounded {sig : Signature} [DecidableEq sig.Sym]
    (rules : RuleList sig) : List (CriticalPair sig) :=
  (rules.flatMap fun r1 =>
    rules.flatMap fun r2 =>
      (overlapsOfRulesBounded r1 r2).filterMap (fun o =>
        match o with
        | (p, sub1, sub2) => mkCriticalPair r1 r2 p sub1 sub2))

theorem mem_ruleSetOfList {sig : Signature} {rules : RuleList sig} {r : Rule sig} :
    ruleSetOfList (sig := sig) rules r ↔ r ∈ rules := by
  rfl

/-- A critical pair of a rule set. -/
def IsCriticalPair {sig : Signature} (rules : RuleSet sig) (cp : CriticalPair sig) : Prop :=
  ∃ r1 r2 p sub1 sub2,
    rules r1 ∧ rules r2 ∧ Overlap r1 r2 p sub1 sub2 ∧
      mkCriticalPair r1 r2 p sub1 sub2 = some cp

/-- The set of critical pairs of a rule set. -/
abbrev CriticalPairs {sig : Signature} (rules : RuleSet sig) : CriticalPair sig -> Prop :=
  IsCriticalPair rules

theorem criticalPairs_mono {sig : Signature} {rules rules' : RuleSet sig}
    {cp : CriticalPair sig} (h : ∀ r, rules r → rules' r) :
    CriticalPairs rules cp → CriticalPairs rules' cp := by
  intro hcp
  rcases hcp with ⟨r1, r2, p, sub1, sub2, hr1, hr2, hover, hmk⟩
  exact ⟨r1, r2, p, sub1, sub2, h _ hr1, h _ hr2, hover, hmk⟩

theorem criticalPairsOfRules_sound {sig : Signature} [DecidableEq sig.Sym]
    {rules : RuleList sig} {cp : CriticalPair sig} :
    cp ∈ criticalPairsOfRules (sig := sig) rules →
    CriticalPairs (ruleSetOfList (sig := sig) rules) cp := by
  intro hmem
  rcases List.mem_flatMap.1 hmem with ⟨r1, hr1, hmem⟩
  rcases List.mem_flatMap.1 hmem with ⟨r2, hr2, hmem⟩
  rcases List.mem_filterMap.1 hmem with ⟨o, ho, hmk⟩
  rcases o with ⟨p, sub1, sub2⟩
  rcases List.mem_filterMap.1 ho with ⟨p0, hp0, hopt⟩
  cases hsub : Term.subterm r1.lhs p0 with
  | none =>
      cases (by simp [hsub] at hopt : False)
  | some t =>
      cases hunify : unify (sig := sig) [(t, r2.lhs)] with
      | none =>
          cases (by simp [hsub, hunify] at hopt : False)
      | some sub =>
          have hopt' : (p0, sub, sub) = (p, sub1, sub2) := by
            simpa [overlapsOfRules, hsub, hunify] using hopt
          rcases Prod.ext_iff.1 hopt' with ⟨hp, hsubs⟩
          rcases Prod.ext_iff.1 hsubs with ⟨hsub1, hsub2⟩
          subst hp
          subst hsub1
          subst hsub2
          have hmk' : mkCriticalPair r1 r2 p0 sub sub = some cp := by
            simpa using hmk
          have hsubterm : Term.subterm (Term.subst sub r1.lhs) p0 = some (Term.subst sub t) := by
            exact Term.subterm_subst (sub := sub) (t := r1.lhs) (p := p0) (u := t) hsub
          have hunifyList : UnifiesList sub [(t, r2.lhs)] :=
            unify_sound (sig := sig) (eqs := [(t, r2.lhs)]) (sub := sub) hunify
          have hEq : Term.subst sub t = Term.subst sub r2.lhs := by
            have := hunifyList (t, r2.lhs) (by simp)
            simpa using this
          have hnonvar : NonVar (Term.subst sub r2.lhs) := by
            cases r2.lhs <;> simp [NonVar, IsVar]
          have hover : Overlap r1 r2 p0 sub sub := by
            exact ⟨by simpa [hEq] using hsubterm, hnonvar⟩
          exact ⟨r1, r2, p0, sub, sub, hr1, hr2, hover, hmk'⟩

theorem criticalPairsOfRules_mono {sig : Signature} [DecidableEq sig.Sym]
    {rules rules' : RuleList sig}
    (hsub : ∀ r, r ∈ rules → r ∈ rules') :
    ∀ cp, cp ∈ criticalPairsOfRules (sig := sig) rules →
      cp ∈ criticalPairsOfRules (sig := sig) rules' := by
  intro cp hmem
  unfold criticalPairsOfRules at hmem ⊢
  rcases List.mem_flatMap.1 hmem with ⟨r1, hr1, hmem⟩
  rcases List.mem_flatMap.1 hmem with ⟨r2, hr2, hmem⟩
  rcases List.mem_filterMap.1 hmem with ⟨o, ho, hmk⟩
  rcases o with ⟨p, sub1, sub2⟩
  refine List.mem_flatMap.2 ?_
  refine ⟨r1, hsub r1 hr1, ?_⟩
  refine List.mem_flatMap.2 ?_
  refine ⟨r2, hsub r2 hr2, ?_⟩
  refine List.mem_filterMap.2 ?_
  exact ⟨(p, sub1, sub2), ho, hmk⟩

theorem criticalPairsOfRules_complete {sig : Signature} [DecidableEq sig.Sym]
    {rules : RuleList sig} {r1 r2 : Rule sig} {p : Pos} {t : Term sig}
    {sub : Subst sig} {cp : CriticalPair sig} :
    r1 ∈ rules →
    r2 ∈ rules →
    Term.subterm r1.lhs p = some t →
    unify (sig := sig) [(t, r2.lhs)] = some sub →
    mkCriticalPair r1 r2 p sub sub = some cp →
    cp ∈ criticalPairsOfRules (sig := sig) rules := by
  intro hr1 hr2 hsub hunify hmk
  unfold criticalPairsOfRules
  refine List.mem_flatMap.2 ?_
  refine ⟨r1, hr1, ?_⟩
  refine List.mem_flatMap.2 ?_
  refine ⟨r2, hr2, ?_⟩
  refine List.mem_filterMap.2 ?_
  refine ⟨(p, sub, sub), ?_, ?_⟩
  · exact overlapsOfRules_complete (r1 := r1) (r2 := r2) hsub hunify
  · simpa using hmk

theorem criticalPairsOfRules_complete_unifiable {sig : Signature} [DecidableEq sig.Sym]
    {rules : RuleList sig} {r1 r2 : Rule sig} {p : Pos} {t : Term sig} :
    r1 ∈ rules →
    r2 ∈ rules →
    Term.subterm r1.lhs p = some t →
    Unifiable (sig := sig) [(t, r2.lhs)] →
    ∃ cp, cp ∈ criticalPairsOfRules (sig := sig) rules := by
  intro hr1 hr2 hsub hunif
  rcases (unifiable_iff_unify (sig := sig) (eqs := [(t, r2.lhs)])).1 hunif with ⟨sub, hunify⟩
  rcases mkCriticalPair_defined_of_subterm (r1 := r1) (r2 := r2) (p := p)
      (t := t) (sub1 := sub) (sub2 := sub) hsub with ⟨cp, hmk⟩
  exact ⟨cp, criticalPairsOfRules_complete (rules := rules) (r1 := r1) (r2 := r2)
    (p := p) (t := t) (sub := sub) (cp := cp) hr1 hr2 hsub hunify hmk⟩

end Metatheory.TRS.FirstOrder
